Tasks
-----

DONE Code SensorData (environment and ego)
DONE Code Behavior class (ignore the Road dependency)
DONE Move Point to Trajectory file.
DONE Refactor classes (see the draft in my notepad)
DONE   Remove all the commented-code
  Only leave the minimum members for each class (At this moment we don't need the acceleration for each vehicle for example)
DONE Code Map
DONE Test Map
DONE Minimum test for the Trajectory generation
DONE   straight line in x, y
DONE   straight line in s, d
DONE   spline line in s, d (Q&A Walkthrough)
DONE Code PopulateTraffic in the Road class
DONE Minimum test for PopulateTraffic with stubbed data
DONE   Stub data. 2 or 3 vehicles + ego

DONE Design a generic SplineStrategy for the trajectory generator, so that it generates a trajectory given the starting kinematics, goal point and a reference velocity (add the latter to TrajectoryStrategy). Think about the perturbed goals... who is going to calculate several trajectories and get the best one? Behavior or TrajectoryStrategy? Consider also previous path, we shouldn't stomp on it before getting the next best path...
DONE Code it
DONE Vehicle::UpdateKinematics -> UpdateState? 
DONE  Who should set the current lane for each vehicle? The vehicle itself? or the Road?... Yes, the vehicle can see the road, so the vehicle itself!
DONE Modify stub so that it has frenet data in the environment vehicles
DONE Code road.IsEmpty(s_down, s_up, d_left, d_right)
DONE Code a simple logic to test the lane change with the spline generator (see behavior.cpp UpdateState())
DONE Add d_desired[state] in Behavior class, so that we can set the goal point in the trajectory strategy. Also s_desired ??
DONE Code the lane inside Vehicle::UpdateState()
DONE SetPossibleTransitions(lane)
  if we are on the most right lane we can change lane right for example
  set possible transitions on each UpdateState() call based on the current lane
DONE GetDesiredD(lane, state)
  d_by_lane_and_state[lane][state]
    d_by_lane_and_state[0][KL] = d_by_lane[0]
    d_by_lane_and_state[0][PCLR] = d_by_lane[0] + LANE_WIDTH/4
    d_by_lane_and_state[0][CLR] = d_by_lane[1]
    
    d_by_lane_and_state[1][KL] = d_by_lane[1]
    d_by_lane_and_state[1][PCLL] = d_by_lane[1] - LANE_WIDTH/4
    d_by_lane_and_state[1][CLL] = d_by_lane[0]
    d_by_lane_and_state[1][PCLR] = d_by_lane[1] + LANE_WIDTH/4
    d_by_lane_and_state[1][CLR] = d_by_lane[2]
    
    d_by_lane_and_state[2][KL] = d_by_lane[2]
    d_by_lane_and_state[2][PCLL] = d_by_lane[2] - LANE_WIDTH/4
    d_by_lane_and_state[2][CLL] = d_by_lane[1]
DONE Move CostFunction out of TrajectoryStrategy, into Behavior.
DONE   CalculateCost(Trajectory t)
DONE Design CostFunction
DONE Design high level of the loop of the trajectory generation: 
  Behavior should calculate several trajectories (perturbed goals) for each possible state (d_desired), calculate the cost for each one and keep the best one.
DONE Code some cost functions (collision detection)

Design how to pass the best trajectory detected to the path planner
Test behavior algorithm without perturbed goal

Design road prediction
Integrate road prediction

Add perturbed goals logic
Test behavior
Code more cost functions
Set weights
Update UML
Code lanes_available detection inside Vehicle::UpdateState()
Test the algorithm

Refactor: TrajectoryStrategy -> TrajectoryGenerator
Refactor: TrajectoryStratgy::GenerateTrajectory() : returns Trajectory
Refactor: remove "using namespace std" from all header files.